
## LOST-01 — Инициализация структуры данных и управление миграциями

### 1. Архитектурный анализ (CoT)
Фича реализуется на уровне Backend и БД: версионируемая схема PostgreSQL через Alembic обеспечивает воспроизводимое развёртывание и откат. Таблицы admins (белый список админов), помещений и собственников/контактов являются пререквизитом для импорта реестра (CORE-01) и всей последующей логики.

### 2. Описание и цель
Создание и поддержка версионируемой схемы БД (миграции Alembic), реализация таблиц для админов, помещений и собственников. Цель — гарантировать наличие структуры данных перед загрузкой реестров и работой приложения.

### 3. Функциональные требования
* **SR-LOST01-001:** Система должна использовать Alembic (или эквивалент) для версионирования схемы PostgreSQL.
* **SR-LOST01-002:** Система должна содержать миграции, создающие таблицу admins (telegram_id, role, created_at — см. модель данных ниже).
* **SR-LOST01-003:** Система должна содержать миграции, создающие таблицу помещений (кадастровый номер/id, площадь, подъезд, этаж, тип помещения, номер помещения и др. атрибуты по реестру).
* **SR-LOST01-004:** Система должна содержать миграции, создающие таблицу собственников/контактов (связь с помещением, контактные данные, зарегистрирован_в_электронном_доме, статус и др. — см. модель данных ниже).
* **SR-LOST01-005:** Система должна содержать миграции, создающие таблицу голосование_в_ОСС (связь с контактом, позиция_за, формат_голоса, в_электронном_доме, проголосовал).
* **SR-LOST01-006:** Применение миграций должно выполняться при развёртывании (или по отдельной команде) без потери данных при последовательном обновлении.
* **SR-LOST01-007:** Откат миграций (downgrade) должен быть описан там, где это безопасно и предусмотрено процессом.

### 4. Сценарий использования
**Триггер:** Первое развёртывание или обновление версии приложения.
**Main Success Scenario:**
1. Оператор запускает применение миграций (alembic upgrade head).
2. Схема БД приводится к актуальной версии; приложение может работать с таблицами.
**Alternative Flows:**
* **AF-1 (Конфликт версий):** При обнаружении расхождений миграции выводят ошибку; оператор устраняет конфликт по документации.
* **AF-2 (Откат):** При необходимости отката выполняется alembic downgrade; данные в откатываемых таблицах должны быть сохранены или явно удалены по политике.

### 5. Модель данных
**Новые сущности:**

* **admins** (белый список админов): telegram_id, role (administrator | super_administrator), created_at. Независимая сущность для авторизации. Использование: проверка при входе (ADM-01), управление составом (ADM-04). Хранение — только в таблице admins в БД (ADM-01, ADM-04).

* **premises:** кадастровый_номер, площадь, подъезд, этаж, тип_помещения, номер_помещения (String — для значений «9А», «IX», «10-б»). Иерархия должна позволять каскадный выбор: подъезд → этаж → тип → номер.

* **contacts** (собственники/анкеты): связь с помещением (premise_id), is_owner, phone (ПДн), email (ПДн), telegram_id (ПДн), как_обращаться (ПДн), зарегистрирован_в_ЭД (bool), согласия/версия политики, дата_создания, дата_последнего_изменения (для дедупликации и аудита, CORE-02), ip, статус (pending / validated / inactive).
Все перечисленные ПДн — только в зашифрованном виде (BE-02)

* **голосование_в_ОСС:** связь с контактом (contact_id), позиция_за, формат_голоса, проголосовал (bool). Данные по участию в ОСС и голосовании.

Связи: контакты → помещение; голосование_в_ОСС → контакт. Использование и маппинг из внешних источников — см. CORE-01 (импорт реестра), FE-04 (форма анкеты).

### 6. Интеграции и API
Не применимо (миграции БД). Команды Alembic выполняются в окружении backend.

### 7. Нефункциональные требования
* **Security:** Миграции не должны содержать тестовых паролей и секретов; чувствительные поля проектируются с учётом последующего шифрования (BE-02).
* **Traceability:** Каждая миграция должна иметь осмысленное описание (revision message).

**Зависимости:** CORE-01 (Импорт реестра) невозможен без выполненного LOST-01.

---

## BE-02 — Шифрование полей phone, email, telegram_id, Обращение

### 1. Архитектурный анализ (CoT)
Реализуется на Backend при записи/чтении в БД. Ключи шифрования хранятся отдельно от БД (файл секрета, монтируемый в контейнер бэкенда). Алгоритм AES-256 или XSalsa20-Poly1305. Модуль логики при сохранении анкеты шифрует поля перед INSERT; при необходимости отображения админу — расшифровывает с логированием доступа.

### 2. Описание и цель
Шифрование контактных полей (phone, email, telegram_id) и поля «Обращение» (как обращаться к собственнику) в БД для соответствия 152-ФЗ и снижения рисков при утечке дампа БД.

### 3. Функциональные требования
* **SR-BE02-001:** Система должна шифровать значение поля «телефон» перед сохранением в БД.
* **SR-BE02-002:** Система должна шифровать значение поля «email» перед сохранением в БД.
* **SR-BE02-003:** Система должна шифровать значение поля «telegram_id» перед сохранением в БД.
* **SR-BE02-010:** Система должна шифровать значение поля «Обращение» (как обращаться к собственнику) перед сохранением в БД.
* **SR-BE02-004:** Шифрование должно выполняться с использованием AES-256, XSalsa20-Poly1305 (или совместимого стандарта).
* **SR-BE02-005:** Мастер-ключ должен монтироваться в контейнер бэкенда как read-only файл по пути `/run/secrets/master_key` с использованием механизма Docker Secrets или bind mount. На хост-машине файл должен находиться вне директории репозитория; рекомендуемый путь — `/etc/opt/mkd-contacts/master.key` с правами доступа 400.
* **SR-BE02-006:** Категорически запрещено передавать мастер-ключ через переменные окружения (ENV), так как они доступны через инспекцию контейнера и логи.
* **SR-BE02-007:** Пользователь СУБД (PostgreSQL/MySQL), под которым приложение подключается к БД, не должен иметь доступа к ключу шифрования: ключ загружается только процессом приложения из файла, к которому у учётной записи БД нет доступа.
* **SR-BE02-008:** Для полей phone, email и telegram_id система должна создавать отдельный Blind Index на базе HMAC-SHA256 с использованием pepper, хранящегося в переменных окружения бэкенда. Результат сохраняется в индексированные колонки `phone_idx`, `email_idx` и `telegram_id_idx` в таблице контактов. Перед хешированием обязательна нормализация: **(а) Телефон** — только цифры, приведение к формату 7XXXXXXXXXX (замена начальной «8» на «7»); **(б) Email** — приведение к нижнему регистру, удаление пробелов; **(в) Telegram ID** — приведение к строковому формату.
* **SR-BE02-009:** При чтении записей для авторизованного админа система должна расшифровывать поля для отображения только в момент запроса и не отдавать расшифрованные значения в логах.

### 4. Сценарий использования
**Триггер:** Сохранение анкеты (FE-04) или чтение контакта админом.
**Main Success Scenario:**
1. При сохранении анкеты бэкенд шифрует phone, email, telegram_id и «Обращение», вычисляет Blind Index для phone, email, telegram_id (после нормализации) и записывает в БД.
2. При запросе контакта админом бэкенд читает запись, расшифровывает поля и отдаёт в ответе (с аудитом чтения).
**Alternative Flows:**
* **AF-1 (Отсутствие ключа):** При старте приложения при отсутствии ключа шифрования приложение не должно стартовать.
* **AF-2 (Повреждённые данные):** При невозможности расшифровки возвращать метку «недоступно» и логировать инцидент.

### 5. Модель данных
**Update:** В БД хранятся зашифрованные строки для полей phone, email, telegram_id и «Обращение» (или ciphertext + iv по выбранной схеме). Структура полей должна позволять однозначно расшифровать при наличии ключа. Для поиска без расшифровки используются индексированные колонки `phone_idx`, `email_idx` и `telegram_id_idx` (Blind Index по SR-BE02-008).

### 6. Интеграции и API
Внутренняя реализация; API приложения отдаёт уже расшифрованные значения (для админа) в ответах, например в `GET /api/admin/contacts` — поля приходят расшифрованными на уровне сервиса.

### 7. Нефункциональные требования
* **Security:** Ключ не должен попадать в логи и репозиторий; ключ подаётся только через файл (Docker Secrets или bind mount). Учётная запись СУБД (database user) не должна иметь доступа к файлу ключа — разделение прав «приложение владеет ключом, БД видит только шифротекст». Ротация ключей — отдельная процедура (документирована).
* ⚠️ **Риск:** Ротация ключей требует процедуры миграции уже зашифрованных данных.

---

## ADM-01 — Auth: Telegram OAuth (white-list)

### 1. Архитектурный анализ (CoT)
Реализуется в Auth Module на Backend (FastAPI): OAuth2 flow с Telegram как провайдером, выдача JWT после успешной авторизации. Сверка с белым списком выполняется по таблице `admins` в БД — единственному легитимному хранилищу. Архитектура предполагает хранение JWT на клиенте и передачу в заголовке Authorization.

### 2. Описание и цель
Авторизация администраторов и суперадминов через Telegram OAuth с проверкой по белому списку. Цель — ограничить доступ к админ-функциям только доверенными лицами.

### 3. Функциональные требования
* **SR-ADM01-001:** Система должна инициировать OAuth-авторизацию через Telegram (редирект на Telegram OAuth или использование Telegram Login Widget). Первый администратор, добавленный через SQL на этапе Bootstrap (SR-ADM01-008), сразу получает возможность авторизоваться через Telegram и получить валидный JWT; проверка JWT в API-запросах к админ-эндпоинтам применяется при наличии хотя бы одной записи в таблице `admins`.
* **SR-ADM01-002:** Система должна получать от Telegram идентификатор пользователя (telegram_id) и при необходимости имя/username после успешной авторизации.
* **SR-ADM01-003:** Система должна проверять telegram_id по белому списку перед выдачей JWT.
* **SR-ADM01-004:** Если telegram_id отсутствует в белом списке, система должна возвращать отказ в доступе и не выдавать JWT.
* **SR-ADM01-005:** Система должна выдавать JWT с указанием роли (administrator / super_administrator) в соответствии с белым списком.
* **SR-ADM01-006:** Система должна защищать эндпоинты админки проверкой JWT и роли.
* **SR-ADM01-007:** Единственным легитимным хранилищем списка администраторов является таблица `admins` в базе данных. Хранение Telegram ID администраторов в конфигурационных файлах (.env, yaml и т.д.) запрещено.
* **SR-ADM01-008 (Bootstrap):** Для инициализации системы (Bootstrap) первый администратор добавляется владельцем системы напрямую в базу данных через SQL-запрос (INSERT в таблицу `admins`). Это позволяет обойти требование наличия Admin-Token для первого входа: после появления записи в `admins` соответствующий пользователь может авторизоваться через Telegram и получить JWT. Технически: выполнение INSERT в контейнере БД (например: `docker compose exec db psql -U <user> -d <db> -c "INSERT INTO admins (telegram_id, role) VALUES (...);"`). Это гарантирует отсутствие чувствительных ID в репозитории и конфигурации.

### 4. Сценарий использования
**Триггер:** Пользователь нажимает «Войти через Telegram» в админ-интерфейсе.
**Main Success Scenario:**
1. Пользователь переходит в Telegram OAuth и подтверждает доступ.
2. Сервер получает callback с данными, проверяет white-list, выдаёт JWT.
3. Клиент сохраняет JWT и перенаправляет в админ-панель.
**Alternative Flows:**
* **AF-1 (Не в white-list):** Сервер возвращает 403 с сообщением «Доступ запрещён».
* **AF-2 (Ошибка Telegram/сеть):** Сервер возвращает 502/503; клиент отображает сообщение «Повторите попытку позже».

### 5. Модель данных
**Затрагиваемые сущности:** Структура таблицы admins — по LOST-01 (§5 выше). ADM-01 использует поля telegram_id и role для проверки при входе; хранение — только в таблице admins в БД (см. ADM-04, SR-ADM01-007).

### 6. Интеграции и API
* **Method:** `GET /api/auth/telegram/callback` (или POST с телом после redirect)
* **Query/body:** Параметры, возвращаемые Telegram OAuth (hash, id, first_name, username и т.д.).
* **Response (успех):**
```json
{
  "access_token": "eyJ...",
  "token_type": "bearer",
  "role": "administrator"
}
```
* **Response (отказ):**
```json
{
  "detail": "Access denied: not in white-list"
}
```

### 7. Нефункциональные требования
* **Security:** JWT с ограниченным временем жизни; белый список хранится только в БД (таблица admins); управление составом — только для суперадмина (ADM-04).
* **Logging:** Логировать факт входа (telegram_id, роль, время) без хранения токена.

---
## ADM-04 — Super-admin UI: добавление/удаление администраторов

### 1. Архитектурный анализ (CoT)
Реализуется в Auth Module и админ-интерфейсе: только суперадмин может добавлять/удалять записи в таблице `admins` в БД. Интерфейс управления администраторами работает исключительно с этой таблицей. UI — форма/таблица и вызов API; Backend проверяет роль super_administrator и наличие вызывающего в таблице admins.

### 2. Описание и цель
Управление составом администраторов: добавление и удаление учётных записей из белого списка Telegram. Цель — БТ раздел 2.3.

### 3. Функциональные требования
* **SR-ADM04-001:** Система должна предоставлять API для добавления записи в белый список админов (telegram_id, роль administrator) только при вызове от пользователя с ролью super_administrator.
* **SR-ADM04-002:** Система должна предоставлять API для удаления записи из белого списка (по telegram_id) только от суперадмина.
* **SR-ADM04-003:** Суперадмин не может удалить сам себя через UI.
* **SR-ADM04-004:** Клиент должен отображать список текущих администраторов и кнопки «Добавить» / «Удалить» (доступно только суперадмину).
* **SR-ADM04-005:** Интерфейс управления администраторами работает исключительно с таблицей `admins` в БД; данные для отображения и изменения берутся только из этой таблицы.
* **SR-ADM04-006:** Создание новых записей в таблице `admins` через API доступно только пользователям, чей telegram_id уже присутствует в этой таблице (т.е. уже авторизованным суперадминистраторам с соответствующей ролью).

### 4. Сценарий использования
**Триггер:** Суперадмин открывает раздел управления админами.
**Main Success Scenario:**
1. Суперадмин вводит Telegram username/id и добавляет администратора; система сохраняет в белый список.
2. При следующем входе новый админ получает JWT с ролью administrator.
**Alternative Flows:**
* **AF-1 (Попытка не суперадмина):** API возвращает 403.
* **AF-2 (Удаление последнего суперадмина):** Запретить.

### 5. Модель данных
**Затрагиваемые сущности:** Структура таблицы admins — по LOST-01 (§5 выше). ADM-04 добавляет и удаляет записи в таблице admins в БД; ограничение: минимум один super_administrator должен существовать в системе. Первая запись создаётся вручную при Bootstrap (ADM-01).

### 6. Интеграции и API
* **Method:** `GET /api/superadmin/admins` — список (без выдачи чувствительных данных).
* **Method:** `POST /api/superadmin/admins` — тело: { "telegram_id": "...", "role": "administrator" }.
* **Method:** `DELETE /api/superadmin/admins/{telegram_id}`.

**Примечание:** Интерфейс управления списком администраторов становится доступен только после успешной авторизации под учётной записью, добавленной на этапе Bootstrap (ADM-01, SR-ADM01-008).

### 7. Нефункциональные требования
* **Security:** Строгая проверка роли; все действия логировать (ADM-05).

---


