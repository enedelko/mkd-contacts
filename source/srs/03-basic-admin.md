
## LOST-01 — Инициализация структуры данных и управление миграциями

### 1. Архитектурный анализ (CoT)
Фича реализуется на уровне Backend и БД: версионируемая схема PostgreSQL через Alembic обеспечивает воспроизводимое развёртывание и откат. Таблицы admins (белый список админов), помещений и собственников/контактов являются пререквизитом для импорта реестра (CORE-01) и всей последующей логики.

### 2. Описание и цель
Создание и поддержка версионируемой схемы БД (миграции Alembic), реализация таблиц для админов, помещений и собственников. Цель — гарантировать наличие структуры данных перед загрузкой реестров и работой приложения.

### 3. Функциональные требования
* **SR-LOST01-001:** Система должна использовать Alembic (или эквивалент) для версионирования схемы PostgreSQL.
* **SR-LOST01-002:** Система должна содержать миграции, создающие таблицу admins (telegram_id, role, created_at — см. модель данных ниже).
* **SR-LOST01-003:** Система должна содержать миграции, создающие таблицу помещений (кадастровый номер/id, площадь, подъезд, этаж, тип помещения, номер помещения и др. атрибуты по реестру).
* **SR-LOST01-004:** Система должна содержать миграции, создающие таблицу собственников/контактов (связь с помещением, контактные данные, зарегистрирован_в_электронном_доме, статус и др. — см. модель данных ниже).
* **SR-LOST01-005:** Система должна содержать миграции, создающие таблицу голосование_в_ОСС (связь с контактом, позиция_за, формат_голоса, в_электронном_доме, проголосовал).
* **SR-LOST01-006:** Применение миграций должно выполняться при развёртывании (или по отдельной команде) без потери данных при последовательном обновлении.
* **SR-LOST01-007:** Откат миграций (downgrade) должен быть описан там, где это безопасно и предусмотрено процессом.

### 4. Сценарий использования
**Триггер:** Первое развёртывание или обновление версии приложения.
**Main Success Scenario:**
1. Оператор запускает применение миграций (alembic upgrade head).
2. Схема БД приводится к актуальной версии; приложение может работать с таблицами.
**Alternative Flows:**
* **AF-1 (Конфликт версий):** При обнаружении расхождений миграции выводят ошибку; оператор устраняет конфликт по документации.
* **AF-2 (Откат):** При необходимости отката выполняется alembic downgrade; данные в откатываемых таблицах должны быть сохранены или явно удалены по политике.

### 5. Модель данных
**Новые сущности:**

* **admins** (белый список админов): telegram_id, role (administrator | super_administrator), created_at. Независимая сущность для авторизации. Использование: проверка при входе (ADM-01), управление составом (ADM-04); допустимо хранение в БД или конфиге.

* **premises:** кадастровый_номер, площадь, подъезд, этаж, тип_помещения, номер_помещения (String — для значений «9А», «IX», «10-б»). Иерархия должна позволять каскадный выбор: подъезд → этаж → тип → номер.

* **contacts** (собственники/анкеты): связь с помещением (premise_id), is_owner, phone (ПДн), email (ПДн), telegram_id (ПДн), как_обращаться (ПДн), зарегистрирован_в_ЭД (bool), согласия/версия политики, дата_создания, дата_последнего_изменения (для дедупликации и аудита, CORE-02), ip, статус (pending / validated / inactive).
Все перечисленные ПДн — только в зашифрованном виде (BE-02)

* **голосование_в_ОСС:** связь с контактом (contact_id), позиция_за, формат_голоса, проголосовал (bool). Данные по участию в ОСС и голосовании.

Связи: контакты → помещение; голосование_в_ОСС → контакт. Использование и маппинг из внешних источников — см. CORE-01 (импорт реестра), FE-04 (форма анкеты).

### 6. Интеграции и API
Не применимо (миграции БД). Команды Alembic выполняются в окружении backend.

### 7. Нефункциональные требования
* **Security:** Миграции не должны содержать тестовых паролей и секретов; чувствительные поля проектируются с учётом последующего шифрования (BE-02).
* **Traceability:** Каждая миграция должна иметь осмысленное описание (revision message).

**Зависимости:** CORE-01 (Импорт реестра) невозможен без выполненного LOST-01.

---

## BE-02 — Шифрование полей phone, email, telegram_id

### 1. Архитектурный анализ (CoT)
Реализуется на Backend при записи/чтении в БД. Ключи шифрования хранятся отдельно от БД (переменные окружения/секреты). Алгоритм AES-256 или XSalsa20-Poly1305. Модуль логики при сохранении анкеты шифрует поля перед INSERT; при необходимости отображения админу — расшифровывает с логированием доступа.

### 2. Описание и цель
Шифрование контактных полей (phone, email, telegram_id) в БД для соответствия 152-ФЗ и снижения рисков при утечке дампа БД.

### 3. Функциональные требования
* **SR-BE02-001:** Система должна шифровать значение поля «телефон» перед сохранением в БД.
* **SR-BE02-002:** Система должна шифровать значение поля «email» перед сохранением в БД.
* **SR-BE02-003:** Система должна шифровать значение поля «telegram_id» перед сохранением в БД.
* **SR-BE02-004:** Шифрование должно выполняться с использованием AES-256, XSalsa20-Poly1305 (или совместимого стандарта).
* **SR-BE02-005:** Система должна хранить мастер-ключ (или ключ шифрования) в файле, доступ к которому имеет только пользователь ОС, под которым запущено приложение/бот (например, права доступа к файлу 0600, владелец — пользователь приложения).
* **SR-BE02-006:** Пользователь СУБД (PostgreSQL/MySQL), под которым приложение подключается к БД, не должен иметь доступа к ключу шифрования: ключ загружается только процессом приложения из файла или окружения, к которым у учётной записи БД нет доступа.
* **SR-BE02-007:** При чтении записей для авторизованного админа система должна расшифровывать поля для отображения только в момент запроса и не отдавать расшифрованные значения в логах.

### 4. Сценарий использования
**Триггер:** Сохранение анкеты (FE-04) или чтение контакта админом.
**Main Success Scenario:**
1. При сохранении анкеты бэкенд шифрует phone, email, telegram_id и записывает в БД.
2. При запросе контакта админом бэкенд читает запись, расшифровывает поля и отдаёт в ответе (с аудитом чтения).
**Alternative Flows:**
* **AF-1 (Отсутствие ключа):** При старте приложения при отсутствии ключа шифрования приложение не должно стартовать.
* **AF-2 (Повреждённые данные):** При невозможности расшифровки возвращать метку «недоступно» и логировать инцидент.

### 5. Модель данных
**Update:** В БД хранятся зашифрованные строки (или ciphertext + iv по выбранной схеме). Структура полей должна позволять однозначно расшифровать при наличии ключа.

### 6. Интеграции и API
Внутренняя реализация; API приложения отдаёт уже расшифрованные значения (для админа) в ответах, например в `GET /api/admin/contacts` — поля приходят расшифрованными на уровне сервиса.

### 7. Нефункциональные требования
* **Security:** Ключ не должен попадать в логи и репозиторий; ключ хранится в файле с правами доступа только для пользователя, под которым запущено приложение. Учётная запись СУБД (database user) не должна иметь доступа к файлу ключа или к переменным окружения с ключом — разделение прав «приложение владеет ключом, БД видит только шифротекст». Ротация ключей — отдельная процедура (документирована).
* ⚠️ **Риск:** Ротация ключей требует процедуры миграции уже зашифрованных данных.

---

## ADM-01 — Auth: Telegram OAuth (white-list)

### 1. Архитектурный анализ (CoT)
Реализуется в Auth Module на Backend (FastAPI): OAuth2 flow с Telegram как провайдером, выдача JWT после успешной авторизации. Сверка с белым списком (БД или конфиг) определяет, выдавать ли токен администратора. Архитектура предполагает хранение JWT на клиенте и передачу в заголовке Authorization.

### 2. Описание и цель
Авторизация администраторов и суперадминов через Telegram OAuth с проверкой по белому списку. Цель — ограничить доступ к админ-функциям только доверенными лицами.

### 3. Функциональные требования
* **SR-ADM01-001:** Система должна инициировать OAuth-авторизацию через Telegram (редирект на Telegram OAuth или использование Telegram Login Widget).
* **SR-ADM01-002:** Система должна получать от Telegram идентификатор пользователя (telegram_id) и при необходимости имя/username после успешной авторизации.
* **SR-ADM01-003:** Система должна проверять telegram_id по белому списку перед выдачей JWT.
* **SR-ADM01-004:** Если telegram_id отсутствует в белом списке, система должна возвращать отказ в доступе и не выдавать JWT.
* **SR-ADM01-005:** Система должна выдавать JWT с указанием роли (administrator / super_administrator) в соответствии с белым списком.
* **SR-ADM01-006:** Система должна защищать эндпоинты админки проверкой JWT и роли.

### 4. Сценарий использования
**Триггер:** Пользователь нажимает «Войти через Telegram» в админ-интерфейсе.
**Main Success Scenario:**
1. Пользователь переходит в Telegram OAuth и подтверждает доступ.
2. Сервер получает callback с данными, проверяет white-list, выдаёт JWT.
3. Клиент сохраняет JWT и перенаправляет в админ-панель.
**Alternative Flows:**
* **AF-1 (Не в white-list):** Сервер возвращает 403 с сообщением «Доступ запрещён».
* **AF-2 (Ошибка Telegram/сеть):** Сервер возвращает 502/503; клиент отображает сообщение «Повторите попытку позже».

### 5. Модель данных
**Затрагиваемые сущности:** Структура таблицы admins — по LOST-01 (§5 выше). ADM-01 использует поля telegram_id и role для проверки при входе; хранение в БД или конфиге (см. ADM-04).

### 6. Интеграции и API
* **Method:** `GET /api/auth/telegram/callback` (или POST с телом после redirect)
* **Query/body:** Параметры, возвращаемые Telegram OAuth (hash, id, first_name, username и т.д.).
* **Response (успех):**
```json
{
  "access_token": "eyJ...",
  "token_type": "bearer",
  "role": "administrator"
}
```
* **Response (отказ):**
```json
{
  "detail": "Access denied: not in white-list"
}
```

### 7. Нефункциональные требования
* **Security:** JWT с ограниченным временем жизни; белый список хранится под контролем (БД с доступом только для суперадмина/конфиг).
* **Logging:** Логировать факт входа (telegram_id, роль, время) без хранения токена.

---
## ADM-04 — Super-admin UI: добавление/удаление администраторов

### 1. Архитектурный анализ (CoT)
Реализуется в Auth Module и админ-интерфейсе: только суперадмин может добавлять/удалять записи в белом списке (БД или конфиг). UI — форма/таблица и вызов API; Backend проверяет роль super_administrator.

### 2. Описание и цель
Управление составом администраторов: добавление и удаление учётных записей из белого списка Telegram. Цель — БТ раздел 2.3.

### 3. Функциональные требования
* **SR-ADM04-001:** Система должна предоставлять API для добавления записи в белый список админов (telegram_id, роль administrator) только при вызове от пользователя с ролью super_administrator.
* **SR-ADM04-002:** Система должна предоставлять API для удаления записи из белого списка (по telegram_id) только от суперадмина.
* **SR-ADM04-003:** Суперадмин не может удалить сам себя через UI.
* **SR-ADM04-004:** Клиент должен отображать список текущих администраторов и кнопки «Добавить» / «Удалить» (доступно только суперадмину).

### 4. Сценарий использования
**Триггер:** Суперадмин открывает раздел управления админами.
**Main Success Scenario:**
1. Суперадмин вводит Telegram username/id и добавляет администратора; система сохраняет в белый список.
2. При следующем входе новый админ получает JWT с ролью administrator.
**Alternative Flows:**
* **AF-1 (Попытка не суперадмина):** API возвращает 403.
* **AF-2 (Удаление последнего суперадмина):** Запретить.

### 5. Модель данных
**Затрагиваемые сущности:** Структура таблицы admins — по LOST-01 (§5 выше). ADM-04 добавляет и удаляет записи; ограничение: минимум один super_administrator должен существовать в системе.

### 6. Интеграции и API
* **Method:** `GET /api/superadmin/admins` — список (без выдачи чувствительных данных).
* **Method:** `POST /api/superadmin/admins` — тело: { "telegram_id": "...", "role": "administrator" }.
* **Method:** `DELETE /api/superadmin/admins/{telegram_id}`.

### 7. Нефункциональные требования
* **Security:** Строгая проверка роли; все действия логировать (ADM-05).

---


