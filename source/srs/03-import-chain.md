# Цепочка импорта реестра

**Порядок: LOST-01 → BE-02 → CORE-01 → LOST-02**

---

## LOST-01 — Инициализация структуры данных и управление миграциями

### 1. Архитектурный анализ (CoT)
Фича реализуется на уровне Backend и БД: версионируемая схема PostgreSQL через Alembic обеспечивает воспроизводимое развёртывание и откат. Таблицы пользователей (белый список админов), помещений и собственников/контактов являются пререквизитом для импорта реестра (CORE-01) и всей последующей логики.

### 2. Описание и цель
Создание и поддержка версионируемой схемы БД (миграции Alembic), реализация таблиц для пользователей, помещений и собственников. Цель — гарантировать наличие структуры данных перед загрузкой реестров и работой приложения.

### 3. Функциональные требования
* **SR-LOST01-001:** Система должна использовать Alembic (или эквивалент) для версионирования схемы PostgreSQL.
* **SR-LOST01-002:** Система должна содержать миграции, создающие таблицу пользователей (в т.ч. для белого списка админов: telegram_id, роль).
* **SR-LOST01-003:** Система должна содержать миграции, создающие таблицу помещений (кадастровый номер/id, площадь, подъезд, этаж, тип помещения, номер помещения и др. атрибуты по реестру).
* **SR-LOST01-004:** Система должна содержать миграции, создающие таблицу собственников/контактов (связь с помещением, контактные данные, статус, позиция по ОСС и др.).
* **SR-LOST01-005:** Применение миграций должно выполняться при развёртывании (или по отдельной команде) без потери данных при последовательном обновлении.
* **SR-LOST01-006:** Откат миграций (downgrade) должен быть описан там, где это безопасно и предусмотрено процессом.

### 4. Сценарий использования
**Триггер:** Первое развёртывание или обновление версии приложения.
**Main Success Scenario:**
1. Оператор запускает применение миграций (alembic upgrade head).
2. Схема БД приводится к актуальной версии; приложение может работать с таблицами.
**Alternative Flows:**
* **AF-1 (Конфликт версий):** При обнаружении расхождений миграции выводят ошибку; оператор устраняет конфликт по документации.
* **AF-2 (Откат):** При необходимости отката выполняется alembic downgrade; данные в откатываемых таблицах должны быть сохранены или явно удалены по политике.

### 5. Модель данных
**Новые сущности:** Таблицы users (или admin_whitelist), premises, contacts (собственники/анкеты) с атрибутами согласно CORE-01 и FE-04. Связи: контакты → помещение; пользователи — независимая сущность для авторизации.

### 6. Интеграции и API
Не применимо (миграции БД). Команды Alembic выполняются в окружении backend.

### 7. Нефункциональные требования
* **Security:** Миграции не должны содержать тестовых паролей и секретов; чувствительные поля проектируются с учётом последующего шифрования (BE-02).
* **Traceability:** Каждая миграция должна иметь осмысленное описание (revision message).

**Зависимости:** CORE-01 (Импорт реестра) невозможен без выполненного LOST-01.

---

## BE-02 — Шифрование полей phone, email, telegram_id

### 1. Архитектурный анализ (CoT)
Реализуется на Backend при записи/чтении в БД. Ключи шифрования хранятся отдельно от БД (переменные окружения/секреты). Алгоритм AES-256 или XSalsa20-Poly1305. Модуль логики при сохранении анкеты шифрует поля перед INSERT; при необходимости отображения админу — расшифровывает с логированием доступа.

### 2. Описание и цель
Шифрование контактных полей (phone, email, telegram_id) в БД для соответствия 152-ФЗ и снижения рисков при утечке дампа БД.

### 3. Функциональные требования
* **SR-BE02-001:** Система должна шифровать значение поля «телефон» перед сохранением в БД.
* **SR-BE02-002:** Система должна шифровать значение поля «email» перед сохранением в БД.
* **SR-BE02-003:** Система должна шифровать значение поля «telegram_id» перед сохранением в БД.
* **SR-BE02-004:** Шифрование должно выполняться с использованием AES-256, XSalsa20-Poly1305 (или совместимого стандарта).
* **SR-BE02-005:** Система должна хранить мастер-ключ (или ключ шифрования) в файле, доступ к которому имеет только пользователь ОС, под которым запущено приложение/бот (например, права доступа к файлу 0600, владелец — пользователь приложения).
* **SR-BE02-006:** Пользователь СУБД (PostgreSQL/MySQL), под которым приложение подключается к БД, не должен иметь доступа к ключу шифрования: ключ загружается только процессом приложения из файла или окружения, к которым у учётной записи БД нет доступа.
* **SR-BE02-007:** При чтении записей для авторизованного админа система должна расшифровывать поля для отображения только в момент запроса и не отдавать расшифрованные значения в логах.

### 4. Сценарий использования
**Триггер:** Сохранение анкеты (FE-04) или чтение контакта админом.
**Main Success Scenario:**
1. При сохранении анкеты бэкенд шифрует phone, email, telegram_id и записывает в БД.
2. При запросе контакта админом бэкенд читает запись, расшифровывает поля и отдаёт в ответе (с аудитом чтения).
**Alternative Flows:**
* **AF-1 (Отсутствие ключа):** При старте приложения при отсутствии ключа шифрования приложение не должно стартовать.
* **AF-2 (Повреждённые данные):** При невозможности расшифровки возвращать метку «недоступно» и логировать инцидент.

### 5. Модель данных
**Update:** В БД хранятся зашифрованные строки (или ciphertext + iv по выбранной схеме). Структура полей должна позволять однозначно расшифровать при наличии ключа.

### 6. Интеграции и API
Внутренняя реализация; API приложения отдаёт уже расшифрованные значения (для админа) в ответах, например в `GET /api/admin/contacts` — поля приходят расшифрованными на уровне сервиса.

### 7. Нефункциональные требования
* **Security:** Ключ не должен попадать в логи и репозиторий; ключ хранится в файле с правами доступа только для пользователя, под которым запущено приложение. Учётная запись СУБД (database user) не должна иметь доступа к файлу ключа или к переменным окружения с ключом — разделение прав «приложение владеет ключом, БД видит только шифротекст». Ротация ключей — отдельная процедура (документирована).
* ⚠️ **Риск:** Ротация ключей требует процедуры миграции уже зашифрованных данных.

---

## CORE-01 — Импорт реестра (CSV/XLS). Учёт собственников и помещений

### 1. Архитектурный анализ (CoT)
Импорт выполняется в Backend (FastAPI), данные сохраняются в PostgreSQL. Модуль логики (Logic Module) расширяется операциями массовой вставки/обновления помещений. Реализация невозможна без выполненного **LOST-01** (схема БД: таблицы помещений и собственников) и **BE-02** (модуль шифрования для ПДн). Блокер для навигации и фильтров — без реестра помещений карта и каскадные фильтры не имеют данных.

### 2. Описание и цель
Инструмент загрузки реестра помещений из файлов CSV/XLS (кадастровые номера, площади, иерархия подъезд–этаж–тип–номер). Цель — наполнение БД базой помещений МКД для последующей навигации и расчёта кворума.

### 3. Функциональные требования
* **SR-CORE01-001:** Система должна принимать файл загрузки через API (доступ только для авторизованного администратора).
* **SR-CORE01-002:** Система должна поддерживать формат CSV с кодировкой UTF-8.
* **SR-CORE01-003:** Система должна поддерживать формат XLS (или XLSX) для чтения листов с данными помещений.
* **SR-CORE01-004:** Система должна извлекать из файла: кадастровый номер (или идентификатор помещения), площадь, подъезд, этаж, тип помещения, номер помещения.
* **SR-CORE01-005:** Система должна валидировать обязательные поля перед записью в БД.
* **SR-CORE01-006:** Система должна записывать валидные строки в таблицу помещений (или эквивалент) в рамках транзакции.
* **SR-CORE01-007:** Система должна возвращать отчёт: количество принятых строк и список ошибок по строкам (при наличии).
* **SR-CORE01-008:** При критической ошибке формата файла система должна откатывать транзакцию и не вносить изменений.
* **SR-CORE01-009:** Номер помещения должен иметь строковый тип (String), чтобы поддерживать значения типа «9А», «IX», «10-б».
* **SR-CORE01-010:** Любые ПДн (ФИО, паспорт, СНИЛС), передаваемые при импорте или в иных сценариях, должны шифроваться бэкендом (согласно BE-02) перед записью в БД и расшифровываться при чтении. Прямая запись открытых ПДн в БД запрещена.

### 4. Сценарий использования
**Триггер:** Администратор загружает файл реестра.
**Main Success Scenario:**
1. Администратор выбирает файл CSV/XLS и отправляет запрос.
2. Система проверяет формат и права, парсит файл, валидирует строки, записывает данные в БД и возвращает отчёт.
**Alternative Flows:**
* **AF-1 (Ошибка валидации):** Если часть строк невалидна, система записывает только валидные и возвращает в отчёте перечень ошибок по номерам строк.
* **AF-2 (Таймаут/недоступность БД):** При недоступности БД система возвращает HTTP 503 и не сохраняет данные.

### 5. Модель данных
**Новые/затрагиваемые сущности:** Помещение (premise/room): кадастровый_номер (или id), площадь, подъезд, этаж, тип_помещения, номер_помещения (String — для значений «9А», «IX», «10-б»), общая_площадь_МКД (если нужна для кворума). Иерархия должна позволять каскадный выбор: подъезд → этаж → тип → номер. ПДн (ФИО, паспорт, СНИЛС при наличии) хранятся только в зашифрованном виде (BE-02).

### 6. Интеграции и API
* **Method:** `POST /api/admin/import/register`
* **Request:** multipart/form-data с полем `file` (CSV или XLS). Заголовок `Authorization: Bearer <JWT>`.
* **Response (успех):**
```json
{
  "accepted": 120,
  "rejected": 3,
  "errors": [
    { "row": 5, "message": "Missing required field: area" },
    { "row": 12, "message": "Invalid cadastral number format" }
  ]
}
```
* **Response (ошибка формата/отказ):**
```json
{
  "detail": "Unsupported file format or corrupted file"
}
```

### 7. Нефункциональные требования
* **Security:** Доступ только для роли администратор/суперадмин; логирование факта импорта и объёма данных (аудит).
* **Performance:** Рекомендуемый лимит размера файла (например, до 5 MB) и таймаут обработки; при больших объёмах — асинхронная задача или батчи.

---

## LOST-02 — Страница загрузки реестров (Upload Page)

### 1. Архитектурный анализ (CoT)
Страница реализуется на Frontend (React) в составе админ-интерфейса и взаимодействует с API импорта (CORE-01). Обеспечивает выбор файла с ПК и мобильных устройств, отображение инструкции по формату и валидацию структуры файла до отправки или на ответе сервера с детализацией ошибки. Связана с CORE-01.

### 2. Описание и цель
Интерфейс загрузки реестров: инструкция по форматам и колонкам, выбор файла (.xlsx, .csv), валидация набора колонок с выдачей критической ошибки и сравнением «Обнаруженные» vs «Ожидаемые» колонки. Цель — снижение ошибок импорта и соответствие ожидаемой структуре данных.

### 3. Функциональные требования
* **SR-LOST02-001:** На странице загрузки должна быть размещена инструкция по поддерживаемым форматам файлов (.xlsx, .csv) и список ожидаемых колонок с описанием.
* **SR-LOST02-002:** Система должна предоставлять возможность выбора файла с ПК (выбор через диалог файловой системы).
* **SR-LOST02-003:** Система должна предоставлять возможность выбора файла с мобильных устройств (поддержка input type file с accept и при необходимости capture для камеры/галереи по политике).
* **SR-LOST02-004:** Система должна выполнять валидацию структуры файла: если набор колонок не совпадает с ожидаемым, должна выдаваться критическая ошибка без выполнения импорта.
* **SR-LOST02-005:** Сообщение об ошибке валидации структуры должно содержать явное сравнение: «Обнаруженные колонки» и «Ожидаемые колонки» (списки названий колонок).
* **SR-LOST02-006:** Критическая ошибка структуры должна отображаться пользователю на странице (и при необходимости возвращаться в теле ответа API при проверке на бэкенде).

### 4. Сценарий использования
**Триггер:** Администратор открывает страницу загрузки реестров.
**Main Success Scenario:**
1. Администратор читает инструкцию, выбирает файл .xlsx или .csv с ожидаемым набором колонок и запускает загрузку.
2. Система проверяет структуру (на клиенте и/или сервере), выполняет импорт и отображает отчёт.
**Alternative Flows:**
* **AF-1 (Ошибка структуры):** Набор колонок не совпадает с ожидаемым — система выдаёт критическую ошибку с сравнением «Обнаруженные колонки» vs «Ожидаемые колонки»; импорт не выполняется.
* **AF-2 (Неподдерживаемый формат/повреждённый файл):** Система отображает сообщение об ошибке формата или целостности файла; импорт не выполняется.

### 5. Модель данных
Не меняется; используются ожидаемые колонки реестра (кадастровый номер, площадь, подъезд, этаж, тип помещения, номер помещения и др. по CORE-01).

### 6. Интеграции и API
* **Method:** `POST /api/admin/import/register` (как в CORE-01). При валидации структуры на бэкенде при несовпадении колонок возвращать 400 с телом:
* **Response (ошибка структуры):**
```json
{
  "detail": "Column structure mismatch",
  "expected_columns": ["cadastral_number", "area", "entrance", "floor", "premise_type", "premise_number"],
  "detected_columns": ["cadastral_number", "area", "entrance", "floor"]
}
```
Клиент отображает сравнение «Обнаруженные колонки» vs «Ожидаемые колонки» на основе полей `detected_columns` и `expected_columns`.

### 7. Нефункциональные требования
* **UX:** Инструкция должна быть видимой до выбора файла; сообщение об ошибке структуры — читаемым и без технического жаргона где возможно.
* **Accessibility:** Элемент выбора файла доступен с клавиатуры и с мобильных устройств.

**Приоритет:** Повышен в связи с блокирующей ролью загрузки реестров для навигации и аналитики; реализация в связке с CORE-01.
